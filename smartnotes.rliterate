{
"root_page":{
"children":[
{
"children":[
{
"children":[],
"id":"acfde4440fd247f18dfc45bc3dfa7e5b",
"paragraphs":[
{
"chunkpath":[
"constants"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"COLOR_SELECTION      = (214, 138, 208)\nCOLOR_SEARCH_BAR     = (108, 138, 173)\nCOLOR_BACKGROUND     = (134, 169, 214)\nCOLOR_ACTIVE         = (25, 204, 25)\nCOLOR_INACTIVE       = (204, 204, 204)\nCOLOR_LINE           = (114, 127, 178)\nCOLOR_NOTE_BG        = (250, 250, 250)\nCOLOR_NOTE_TEXT      = (20, 20, 20)\nCOLOR_NOTE_DATE_TEXT = (100, 100, 100)\nCOLOR_NOTE_TAG_TEXT  = (100, 100, 255)\nFONT_MONOSPACE       = \"Monospace\"\nFONT_TEXT            = \"San-Serif\"\nEDITOR_COMMAND       = [\"gvim\", \"--nofork\", None]\nNUM_SEARCH_RESULTS   = 6\n",
"type":"code"
}
],
"id":"72d23ce3a4134014b86bc49307e14d99",
"type":"code"
}
],
"title":"Settings"
},
{
"children":[
{
"children":[
{
"children":[],
"id":"4a067f248a754ee1810cf3847b53c8b7",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class SearchField(TextField):\n\n    def __init__(self, search_results, dismiss_callback, **kwargs):\n        TextField.__init__(self, search_results.update_search_text, **kwargs)\n        self.search_results = search_results\n        self.dismiss_callback = dismiss_callback\n\n    def process_event(self, event):\n        if self.has_focus() and event.type == pygame.KEYDOWN and event.mod & pygame.KMOD_CTRL and event.key == pygame.K_g:\n            self.dismiss_callback(close=True)\n        elif self.has_focus() and event.type == pygame.KEYDOWN and event.mod & pygame.KMOD_CTRL and event.key == pygame.K_w:\n            self.set_text(strip_last_word(self.text))\n        elif self.has_focus() and event.type == pygame.KEYDOWN and event.mod & pygame.KMOD_CTRL and event.key == pygame.K_EQUALS:\n            self.search_results.inc_results()\n        elif self.has_focus() and event.type == pygame.KEYDOWN and event.mod & pygame.KMOD_CTRL and event.key == pygame.K_MINUS:\n            self.search_results.dec_results()\n        elif self.has_focus() and event.type == pygame.KEYDOWN and event.key == pygame.K_BACKSPACE:\n            self.set_text(self.text[:-1])\n        elif self.has_focus() and event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:\n            self.dismiss_callback(close=False)\n        else:\n            TextField.process_event(self, event)\n",
"type":"code"
}
],
"id":"d3269ff2d7fc4237bd8d03ba444183a8",
"type":"code"
}
],
"title":"Search Field"
},
{
"children":[],
"id":"1603a24a45284d6aa9f14ffe6d0b7764",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class SearchResults(HBox):\n\n    def __init__(self, db, state, open_callback, hpadding):\n        HBox.__init__(self)\n        self.db = db\n        self.state = state\n        self.open_callback = open_callback\n        self.hpadding = hpadding\n        self.update_search_text(\"\")\n        self.set_num_results(NUM_SEARCH_RESULTS)\n        self.by_id = {}\n\n    def inc_results(self):\n        self.set_num_results(self.num_results + 1)\n\n    def dec_results(self):\n        self.set_num_results(self.num_results - 1)\n\n    def set_num_results(self, num):\n        self.num_results = max(3, min(12, num))\n\n    def update_search_text(self, text):\n        self.text = text\n\n    def ",
"type":"code"
},
{
"id":"8cce3dd9f80645e6a8df699f872f1736",
"type":"variable"
},
{
"text":"(self, ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":"):\n        self.wanted_height = int(round((rect.width-self.hpadding)/self.num_results*3/5))\n        self._update_notes_list()\n        HBox.update(self, rect, elapsed_ms)\n\n    def _update_notes_list(self):\n        by_id = {}\n        self.clear()\n        self.add(Widget(width=self.hpadding/2))\n        for note_id, note_data in self.db.get_notes(self.text)[:self.num_results]:\n            if note_id in self.by_id:\n                note = self.add(self.by_id[note_id])\n            else:\n                note = self.add(Padding(\n                    SearchNote(\n                        self.db,\n                        self.state,\n                        note_id,\n                        self.open_callback\n                    ),\n                    hpadding=lambda rect: self.hpadding/2\n                ))\n            by_id[note_id] = note\n        while len(self.children) <= self.num_results:\n            self.add(Widget())\n        self.add(Widget(width=self.hpadding/2))\n        self.by_id = by_id\n",
"type":"code"
}
],
"id":"2c9d0470d81f48f08dde382dadd0c2d2",
"type":"code"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class SearchNote(",
"type":"code"
},
{
"id":"137180d5603e43c7a4a6224ea4c709fc",
"type":"variable"
},
{
"text":"):\n\n    def __init__(self, db, state, note_id, open_callback):\n        ",
"type":"code"
},
{
"id":"137180d5603e43c7a4a6224ea4c709fc",
"type":"variable"
},
{
"text":".__init__(self, db, note_id, state)\n        self.open_callback = open_callback\n\n    def process_event(self, event):\n        if event.type == pygame.MOUSEMOTION:\n            if self.rect.collidepoint(event.pos):\n                self.state.set_link_target(self)\n                self.quick_focus()\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            if self.rect.collidepoint(event.pos):\n                self.state.set_link_source(self)\n        elif event.type == pygame.MOUSEBUTTONUP:\n            if self.rect.collidepoint(event.pos):\n                self.open_callback(self.note_id)\n\n    def update(self, rect, elapsed_ms):\n        ",
"type":"code"
},
{
"id":"137180d5603e43c7a4a6224ea4c709fc",
"type":"variable"
},
{
"text":".update(self, rect, elapsed_ms)\n        self.rect = self._get_target(rect, align=\"center\")\n",
"type":"code"
}
],
"id":"88e8cf358531425892075ad8aeed935c",
"type":"code"
}
],
"title":"Search Results"
}
],
"id":"adaef2134a284e998e6969dd65013fdf",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class SearchBar(VBox):\n\n    SEARCH_FIELD_HEIHGT = 50\n    VPADDING = 8\n\n    def __init__(self, db, state, open_callback, dismiss_callback):\n        VBox.__init__(self, height=0, visible=False)\n        self.db = db\n        self.state = state\n        self.open_callback = open_callback\n        self.dismiss_callback = dismiss_callback\n        self.animation = Animation()\n        self.notes = []\n        self.search_results = SearchResults(\n            db, state, open_callback,\n            hpadding=self.VPADDING\n        )\n        self.search_field = SearchField(\n            self.search_results,\n            self.dismiss_callback,\n            text_size=20\n        )\n        self.add(Padding(\n            self.search_field,\n            hpadding=lambda rect: int(rect.width*0.08),\n            vpadding=lambda rect: self.VPADDING,\n            height=self.SEARCH_FIELD_HEIHGT\n        ))\n        self.add(self.search_results)\n        self.add(Widget(height=self.VPADDING))\n        self.ideal_height = 200\n\n    def focus(self):\n        self.search_field.focus()\n\n    def is_visible(self):\n        return Widget.is_visible(self) or self.animation.active()\n\n    def start_search(self):\n        if not Widget.is_visible(self):\n            self.toggle_visible()\n            self.animation.reverse(200)\n        self.focus()\n\n    def hide(self):\n        if Widget.is_visible(self):\n            self.toggle_visible()\n            self.animation.reverse(200)\n\n    def ",
"type":"code"
},
{
"id":"8cce3dd9f80645e6a8df699f872f1736",
"type":"variable"
},
{
"text":"(self, ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":"):\n        self.ideal_rect = rect.copy()\n        self.ideal_rect.height = self.ideal_height\n        VBox.update(self, self.ideal_rect, elapsed_ms)\n        self.ideal_height = self.SEARCH_FIELD_HEIHGT + self.VPADDING + self.search_results.wanted_height\n        percent = self.animation.advance(",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":")\n        if Widget.is_visible(self):\n            self.alpha = int(255 * percent)\n            self.resize(height=int(self.ideal_height * percent))\n        else:\n            self.alpha = 255 - int(255 * percent)\n            self.resize(height=self.ideal_height - int(self.ideal_height * percent))\n\n    def ",
"type":"code"
},
{
"id":"acab4c17f89046f4a05b14a8c35ad89a",
"type":"variable"
},
{
"text":"(self, canvas):\n        canvas.blit(\n            canvas.create_image(self.ideal_rect.size, self._draw_search_bar_image),\n            (0, -self.ideal_height+self.get_height()),\n            alpha=self.alpha\n        )\n\n    def _draw_search_bar_image(self, canvas):\n        canvas.fill_rect(\n            pygame.Rect(0, 0, self.ideal_rect.width, self.ideal_rect.height),\n            color=COLOR_SEARCH_BAR\n        )\n        VBox.draw(self, canvas)\n",
"type":"code"
}
],
"id":"6c37a4f747b84ad493d88f40beedcc16",
"type":"code"
}
],
"title":"Search Bar"
},
{
"children":[
{
"children":[],
"id":"dda1c0bec5d446cf9ac2dcefa16948fe",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"ac730e733b7b46e49245a174f805ac8d",
"type":"variable"
},
{
"text":"(",
"type":"code"
},
{
"id":"137180d5603e43c7a4a6224ea4c709fc",
"type":"variable"
},
{
"text":"):\n\n    def __init__(self, db, note_id, state):\n        ",
"type":"code"
},
{
"id":"137180d5603e43c7a4a6224ea4c709fc",
"type":"variable"
},
{
"text":".__init__(self, db, note_id, state)\n        self.incoming = []\n        self.outgoing = []\n        self.animation = Animation()\n        self.rect = None\n        self.target = None\n        self.previous = None\n\n    def clear_hidden_links(self, visible_links):\n        self.incoming = [x for x in self.incoming if x in visible_links]\n        self.outgoing = [x for x in self.outgoing if x in visible_links]\n\n    def process_event(self, event):\n        if event.type == pygame.MOUSEMOTION and self.rect.collidepoint(event.pos):\n            self.state.set_link_target(self)\n            self.quick_focus()\n        if not self.has_focus():\n            return\n        if event.type == pygame.KEYDOWN and event.unicode == \"e\":\n            self.clear_quick_focus()\n            self.post_event(\n                USER_EVENT_EXTERNAL_TEXT_ENTRY,\n                entry=",
"type":"code"
},
{
"id":"8545e167bfcc4a79a004d99b674f6ca1",
"type":"variable"
},
{
"text":"(self.db, self.note_id)\n            )\n        elif event.type == pygame.KEYDOWN and event.unicode == \"d\":\n            self.clear_quick_focus()\n            self.db.delete_note(self.note_id)\n        elif event.type == pygame.KEYDOWN and event.unicode == \"u\":\n            link_id = self.get_link_id()\n            if link_id:\n                self.db.delete_link(link_id)\n                self.clear_quick_focus()\n        elif event.type == pygame.KEYDOWN and event.unicode == \"g\":\n            for link in self.data.get(\"links\", []):\n                webbrowser.open(link)\n        elif event.type == pygame.KEYDOWN and event.unicode == \"c\":\n            self.clear_quick_focus()\n            with self.db.transaction():\n                child_note_id = self.db.create_note(text=\"Enter note text...\\n\")\n                self.db.create_link(self.note_id, child_note_id)\n            self.post_event(\n                USER_EVENT_EXTERNAL_TEXT_ENTRY,\n                entry=",
"type":"code"
},
{
"id":"8545e167bfcc4a79a004d99b674f6ca1",
"type":"variable"
},
{
"text":"(self.db, child_note_id)\n            )\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            self.state.set_link_source(self)\n\n    def update_incoming(self):\n        by_id = {\n            link.link_id: link\n            for link in self.incoming\n        }\n        self.incoming = []\n        for link_id, link_data in self.db.",
"type":"code"
},
{
"id":"4b5405a3ae174b3e9bb6938c905bb18e",
"type":"variable"
},
{
"text":"(self.note_id):\n            if link_id in by_id:\n                self.incoming.append(by_id.pop(link_id))\n            else:\n                ",
"type":"code"
},
{
"id":"c2242de47b1049bb9dddb0f72abeea0c",
"type":"variable"
},
{
"text":"(\n                    self.db,\n                    link_id,\n                    ",
"type":"code"
},
{
"id":"ac730e733b7b46e49245a174f805ac8d",
"type":"variable"
},
{
"text":"(self.db, link_data[\"from\"], self.state),\n                    self\n                )\n        return self.incoming\n\n    def update_outgoing(self):\n        by_id = {\n            link.link_id: link\n            for link in self.outgoing\n        }\n        self.outgoing = []\n        for link_id, link_data in self.db.",
"type":"code"
},
{
"id":"6b3f131bafd84a0eafcc6a947995a761",
"type":"variable"
},
{
"text":"(self.note_id):\n            if link_id in by_id:\n                self.outgoing.append(by_id.pop(link_id))\n            else:\n                ",
"type":"code"
},
{
"id":"c2242de47b1049bb9dddb0f72abeea0c",
"type":"variable"
},
{
"text":"(\n                    self.db,\n                    link_id,\n                    self,\n                    ",
"type":"code"
},
{
"id":"ac730e733b7b46e49245a174f805ac8d",
"type":"variable"
},
{
"text":"(self.db, link_data[\"to\"], self.state)\n                )\n        return self.outgoing\n\n    def get_link_id(self):\n        if self.side == \"left\" and len(self.outgoing) == 1:\n            return self.outgoing[0].link_id\n        if self.side == \"right\" and len(self.incoming) == 1:\n            return self.incoming[0].link_id\n\n    def ",
"type":"code"
},
{
"id":"8cce3dd9f80645e6a8df699f872f1736",
"type":"variable"
},
{
"text":"(self, ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":", side, fade_from_rect):\n        ",
"type":"code"
},
{
"id":"137180d5603e43c7a4a6224ea4c709fc",
"type":"variable"
},
{
"text":".",
"type":"code"
},
{
"id":"8cce3dd9f80645e6a8df699f872f1736",
"type":"variable"
},
{
"text":"(self, ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":")\n        self.side = side\n        self.true_rect = ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":"\n        target = self._get_target(",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":", side)\n        if fade_from_rect:\n            x = target.copy()\n            x.center = fade_from_rect.center\n            self.rect = self.target = self.previous = x\n        if self.rect is None:\n            self.rect = self.target = self.previous = target\n        if target != self.target:\n            if self.animation.active():\n                self.rect = self.target\n            self.target = target\n            self.previous = self.rect\n            self.animation.start(300)\n        if self.animation.active():\n            x_diff = self.target.width - self.previous.width\n            y_diff = self.target.height - self.previous.height\n            percent = self.animation.advance(",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":")\n            self.rect = self.previous.inflate(x_diff*percent, y_diff*percent).move(\n                (\n                    pygame.math.Vector2(self.target.center)-\n                    pygame.math.Vector2(self.previous.center)\n                )*percent\n            )\n\n    def ",
"type":"code"
},
{
"id":"acab4c17f89046f4a05b14a8c35ad89a",
"type":"variable"
},
{
"text":"(self, canvas):\n        ",
"type":"code"
},
{
"id":"137180d5603e43c7a4a6224ea4c709fc",
"type":"variable"
},
{
"text":".",
"type":"code"
},
{
"id":"acab4c17f89046f4a05b14a8c35ad89a",
"type":"variable"
},
{
"text":"(self, canvas)\n        if DEBUG_NOTE_BORDER:\n            canvas.draw_rect(self.true_rect, (255, 0, 0), 1)\n",
"type":"code"
}
],
"id":"59db46405da04e59a0fcc6395c11b4c7",
"type":"code"
}
],
"title":"Note"
},
{
"children":[],
"id":"ac31bc39ff0e49079dc541eba93f8ca0",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"c2242de47b1049bb9dddb0f72abeea0c",
"type":"variable"
},
{
"text":"(Widget):\n\n    def __init__(self, db, link_id, start, end):\n        Widget.__init__(self)\n        self.db = db\n        self.link_id = link_id\n        self.start = start\n        self.end = end\n        self.start.outgoing.append(self)\n        self.end.incoming.append(self)\n        self.start_pos = None\n        self.end_pos = None\n\n    def ",
"type":"code"
},
{
"id":"8cce3dd9f80645e6a8df699f872f1736",
"type":"variable"
},
{
"text":"(self, ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":"):\n        start = pygame.math.Vector2(self.start.rect.midright)\n        end = pygame.math.Vector2(self.end.rect.midleft)\n        if start != self.start_pos or end != self.end_pos:\n            self.start_pos = start\n            self.end_pos = end\n            self.padding = 3\n            self.need_redraw = True\n        else:\n            self.need_redraw = False\n\n    def ",
"type":"code"
},
{
"id":"acab4c17f89046f4a05b14a8c35ad89a",
"type":"variable"
},
{
"text":"(self, canvas):\n        if self.need_redraw:\n            self.width = max(1, int(abs(self.start_pos.x-self.end_pos.x)))\n            self.height = max(1, int(abs(self.start_pos.y-self.end_pos.y)))+2*self.padding\n            self.image = canvas.create_image(\n                (self.width, self.height),\n                self._draw_line\n            )\n            self.pos = (\n                min(self.start_pos.x, self.end_pos.x),\n                min(self.start_pos.y, self.end_pos.y)-self.padding,\n            )\n        canvas.blit(self.image, self.pos)\n\n    def _draw_line(self, canvas):\n        if self.start_pos.x < self.end_pos.x:\n            startx = 0\n            endx = self.width\n            c1x = 0.6*self.width\n            c2x = 0.4*self.width\n        else:\n            startx = self.width\n            endx = 0\n            c1x = 0.4*self.width\n            c2x = 0.6*self.width\n        if self.start_pos.y < self.end_pos.y:\n            starty = self.padding\n            endy = self.height-self.padding\n            c1y = 0.0*(self.height-self.padding)+self.padding\n            c2y = 1.0*(self.height-self.padding)+self.padding\n        else:\n            starty = self.height-self.padding\n            endy = self.padding\n            c1y = 1.0*(self.height-self.padding)+self.padding\n            c2y = 0.0*(self.height-self.padding)+self.padding\n        canvas.move_to(startx, starty)\n        canvas.line_to(startx+0.02*(endx-startx), starty)\n        canvas.curve_to(c1x, c1y, c2x, c2y, endx-0.02*(endx-startx), endy)\n        canvas.line_to(endx, endy)\n        canvas._set_color(COLOR_LINE)\n        canvas.set_line_width(1.5)\n        canvas.stroke()\n",
"type":"code"
}
],
"id":"74ec1cb2afa248b797732e6d32a22aac",
"type":"code"
}
],
"title":"Link"
}
],
"id":"08adce5dbad448b188b0f216518bed41",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"937919ed2e2c41cca33d85a681729a69",
"type":"variable"
},
{
"text":"(Widget):\n\n    def __init__(self, db, state, request_search_callback):\n        Widget.__init__(self)\n        self.db = db\n        self.state = state\n        self.request_search_callback = request_search_callback\n        self.pos = (-1, -1)\n        self.notes = []\n        self.open_last_note()\n\n    def open_last_note(self):\n        self.root_note = None\n        for note_id, note_data in self.db.get_notes():\n            self.",
"type":"code"
},
{
"id":"550c4c8b55b444af9a0463ba8be1c5b9",
"type":"variable"
},
{
"text":"(note_id)\n            break\n\n    def process_event(self, event):\n        if event.type == pygame.MOUSEMOTION:\n            self.pos = event.pos\n        if event.type == pygame.MOUSEBUTTONUP:\n            if self.rect.collidepoint(event.pos):\n                self.focus()\n            for note in reversed(self.notes):\n                if note.rect.collidepoint(event.pos):\n                    self.make_root(note)\n                    return\n        elif event.type == pygame.KEYDOWN and event.key == pygame.K_SLASH and self.has_focus():\n            self.request_search_callback()\n        elif event.type == pygame.KEYDOWN and event.unicode == \"c\" and self.has_focus():\n            note_id = self.db.create_note(text=\"Enter note text...\\n\")\n            self.",
"type":"code"
},
{
"id":"550c4c8b55b444af9a0463ba8be1c5b9",
"type":"variable"
},
{
"text":"(note_id)\n            self.post_event(\n                USER_EVENT_EXTERNAL_TEXT_ENTRY,\n                entry=",
"type":"code"
},
{
"id":"8545e167bfcc4a79a004d99b674f6ca1",
"type":"variable"
},
{
"text":"(self.db, note_id)\n            )\n        else:\n            for note in self.notes:\n                note.process_event(event)\n\n    def ",
"type":"code"
},
{
"id":"550c4c8b55b444af9a0463ba8be1c5b9",
"type":"variable"
},
{
"text":"(self, note_id):\n        self.make_root(",
"type":"code"
},
{
"id":"ac730e733b7b46e49245a174f805ac8d",
"type":"variable"
},
{
"text":"(self.db, note_id, self.state))\n\n    def make_root(self, node):\n        if node is not self.root_note:\n            self.root_note = node\n            self.clear_quick_focus()\n\n    def ",
"type":"code"
},
{
"id":"8cce3dd9f80645e6a8df699f872f1736",
"type":"variable"
},
{
"text":"(self, ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":"):\n        self.rect = rect\n        self.stripe_rects = []\n        padding = 8\n        self.state.set_full_note_width(int(",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":".width * 0.3))\n        self.old_nodes = self.notes\n        self.notes = []\n        self.links = []\n        middle_stripe = self._stripe(",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":", 0.3)\n        if self.root_note and self.root_note.is_deleted():\n            self.open_last_note()\n        if self.root_note is None:\n            return\n        self.root_note.",
"type":"code"
},
{
"id":"8cce3dd9f80645e6a8df699f872f1736",
"type":"variable"
},
{
"text":"(\n            middle_stripe,\n            ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":",\n            \"center\",\n            None\n        )\n        self.notes.append(self.root_note)\n        sizes = [\n            (",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":".width*0.05, ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":".width*0.15),\n            (",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":".width*0.03, ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":".width*0.1),\n        ]\n        self._stripe_recursive(\n            self.root_note,\n            middle_stripe,\n            sizes,\n            ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":",\n            padding,\n            \"left\"\n        )\n        self._stripe_recursive(\n            self.root_note,\n            middle_stripe,\n            sizes,\n            ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":",\n            padding,\n            \"right\"\n        )\n        for link in self.links:\n            link.",
"type":"code"
},
{
"id":"8cce3dd9f80645e6a8df699f872f1736",
"type":"variable"
},
{
"text":"(None, ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":")\n        for note in self.notes:\n            note.clear_hidden_links(self.links)\n\n    def _stripe_recursive(self, note, parent_rect, widths, ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":", padding, direction):\n        if not widths:\n            return\n        parent_rect = parent_rect.inflate(0, -padding)\n        if direction == \"left\":\n            links = note.update_incoming()\n        else:\n            links = note.update_outgoing()\n        if links:\n            space_width, stripe_width = widths[0]\n            if direction == \"left\":\n                rect = parent_rect.move(-space_width-stripe_width, 0)\n                rect.width = stripe_width\n            else:\n                rect = parent_rect.move(parent_rect.width+space_width, 0)\n                rect.width = stripe_width\n            self.stripe_rects.append(rect)\n            for link, y_center, height in self._vertical_stripes(rect, links):\n                if direction == \"left\":\n                    stripe = pygame.Rect(rect.x, 0, stripe_width, height)\n                    linked = link.start\n                else:\n                    stripe = pygame.Rect(rect.x, 0, stripe_width, height)\n                    linked = link.end\n                stripe.centery = y_center\n                linked.",
"type":"code"
},
{
"id":"8cce3dd9f80645e6a8df699f872f1736",
"type":"variable"
},
{
"text":"(\n                    stripe.inflate(0, -padding),\n                    ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":",\n                    direction,\n                    note.rect if linked not in self.old_nodes else None\n                )\n                self.notes.insert(0, linked)\n                self.links.append(link)\n                self._stripe_recursive(linked, stripe, widths[1:], ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":", int(padding*0.8), direction)\n\n    def _vertical_stripes(self, rect, links):\n        if rect.collidepoint(self.pos):\n            even_height = rect.height / len(links)\n            even_width = even_height * 5/3\n            if rect.width < even_width:\n                yield from self._vertical_stripes_even(rect, links)\n            else:\n                yield from self._vertical_stripes_fish_eye(rect, links)\n        else:\n            yield from self._vertical_stripes_even(rect, links)\n\n    def _vertical_stripes_fish_eye(self, rect, links):\n        fractions = []\n        even_height = rect.height / len(links)\n        for index, link in enumerate(links):\n            center_y = rect.y+index*even_height+even_height/2\n            y_diff = abs(center_y - self.pos[1])\n            fractions.append(max(even_height*3-y_diff, even_height))\n        one_fraction_h = rect.height / sum(fractions)\n        y = 0\n        for fraction, link in zip(fractions, links):\n            h = one_fraction_h * fraction\n            yield (link, rect.y+y+h/2, h)\n            y += h\n\n    def _vertical_stripes_even(self, rect, links):\n        even_height = rect.height / len(links)\n        y = 0\n        for link in links:\n            yield (link, rect.y+y+even_height/2, even_height)\n            y += even_height\n\n    def _stripe(self, rect, factor=0.2):\n        stripe = rect.copy()\n        stripe.width *= factor\n        stripe.centerx = rect.centerx\n        return stripe\n\n    def ",
"type":"code"
},
{
"id":"acab4c17f89046f4a05b14a8c35ad89a",
"type":"variable"
},
{
"text":"(self, canvas):\n        if DEBUG_NOTE_BORDER:\n            for rect in self.stripe_rects:\n                canvas.draw_rect(rect, (255, 255, 0), 2)\n        if self.has_focus():\n            canvas.draw_rect(self.rect.inflate(-2, -2), COLOR_SELECTION, 2)\n        for link in self.links:\n            link.",
"type":"code"
},
{
"id":"acab4c17f89046f4a05b14a8c35ad89a",
"type":"variable"
},
{
"text":"(canvas)\n        for note in self.notes:\n            note.",
"type":"code"
},
{
"id":"acab4c17f89046f4a05b14a8c35ad89a",
"type":"variable"
},
{
"text":"(canvas)\n",
"type":"code"
}
],
"id":"3e4e2f6747ce48c0bd359d776fe37203",
"type":"code"
}
],
"title":"Network"
},
{
"children":[],
"id":"e0501d9c681a41d693f6304f1066c410",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class DebugBar(Widget):\n\n    IDEAL_HEIGHT = 50\n\n    def __init__(self):\n        Widget.__init__(self, height=self.IDEAL_HEIGHT, visible=DEBUG)\n        self.animation = Animation()\n        self.average_elapsed = 0\n        self.tot_elapsed_time = 0\n        self.frame_count = 0\n        self.fps = 0\n\n    def is_visible(self):\n        return Widget.is_visible(self) or self.animation.active()\n\n    def toggle(self):\n        self.toggle_visible()\n        self.animation.reverse(200)\n\n    def ",
"type":"code"
},
{
"id":"8cce3dd9f80645e6a8df699f872f1736",
"type":"variable"
},
{
"text":"(self, ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":"):\n        self.tot_elapsed_time += ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":"\n        self.frame_count += 1\n        if self.tot_elapsed_time > 1000:\n            self.average_elapsed = int(round(self.tot_elapsed_time / self.frame_count))\n            self.fps = self.frame_count\n            self.frame_count = 0\n            self.tot_elapsed_time -= 1000\n        percent = self.animation.advance(",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":")\n        if Widget.is_visible(self):\n            self.alpha = int(255 * percent)\n            self.resize(height=int(self.IDEAL_HEIGHT * percent))\n        else:\n            self.alpha = 255 - int(255 * percent)\n            self.resize(height=self.IDEAL_HEIGHT - int(self.IDEAL_HEIGHT * percent))\n        self.rect = ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":"\n\n    def ",
"type":"code"
},
{
"id":"acab4c17f89046f4a05b14a8c35ad89a",
"type":"variable"
},
{
"text":"(self, canvas):\n        canvas.blit(\n            canvas.create_image((self.rect.width, self.IDEAL_HEIGHT), self._draw_bar),\n            self.rect,\n            alpha=self.alpha\n        )\n\n    def _draw_bar(self, canvas):\n        rect = pygame.Rect((0, 0), (self.rect.width, self.IDEAL_HEIGHT))\n        canvas.fill_rect(rect, color=(84, 106, 134))\n        canvas.render_text(\n            f\"elapsed_ms = {self.average_elapsed} | fps = {self.fps}\",\n            rect.inflate(-20, -20),\n            boxalign=\"midleft\",\n            size=15,\n            face=\"Monospace\"\n        )\n",
"type":"code"
}
],
"id":"6a6c0cb5fc2046adb32e564a7508092d",
"type":"code"
}
],
"title":"Debug Bar"
}
],
"id":"b17eddb07f8b4136b13f4ff0ee638bc0",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"28992293e2f14729bfa7acc3ba2d153d",
"type":"variable"
},
{
"text":"(VBox):\n\n    def __init__(self, path):\n        VBox.__init__(self)\n        self.link_source = None\n        self.link_target = None\n        self.full_note_width = 0\n        self.db = ",
"type":"code"
},
{
"id":"03a7c6b0000146f5ba3d059fd0936900",
"type":"variable"
},
{
"text":"(path)\n        self.pos = (0, 0)\n        self.search_bar = self.add(SearchBar(\n            self.db,\n            self,\n            open_callback=self._on_search_note_open,\n            dismiss_callback=self._on_search_dismiss\n        ))\n        self.network = self.add(",
"type":"code"
},
{
"id":"937919ed2e2c41cca33d85a681729a69",
"type":"variable"
},
{
"text":"(\n            self.db,\n            self,\n            request_search_callback=self._on_search_request\n        ))\n        self.debug_bar = self.add(DebugBar())\n        self.network.focus()\n\n    def get_full_note_width(self):\n        return max(100, self.full_note_width)\n\n    def set_full_note_width(self, width):\n        self.full_note_width = width\n\n    def set_link_source(self, link_source):\n        self.link_source = link_source\n\n    def set_link_target(self, link_target):\n        if link_target is None:\n            self.link_target = None\n            return\n        if self.link_source is None:\n            return\n        if self.link_source.note_id == link_target.note_id:\n            return\n        self.link_target = link_target\n\n    def process_event(self, event):\n        if event.type == pygame.MOUSEMOTION:\n            self.pos = event.pos\n            self.set_link_target(None)\n            self.clear_quick_focus()\n        if event.type == pygame.ACTIVEEVENT and event.state == 1:\n            if event.gain:\n                self.restore_focus()\n            else:\n                self.store_focus()\n        if self.link_source and event.type == pygame.MOUSEBUTTONUP:\n            if self.link_target:\n                self.db.create_link(\n                    self.link_source.note_id,\n                    self.link_target.note_id\n                )\n                self.set_link_source(None)\n                self.set_link_target(None)\n                return\n            self.set_link_source(None)\n            self.set_link_target(None)\n        if event.type == pygame.KEYDOWN and event.mod & pygame.KMOD_CTRL and event.key == pygame.K_q:\n            self.quit()\n        if event.type == pygame.KEYDOWN and event.mod & pygame.KMOD_CTRL and event.key == pygame.K_z:\n            self.db.undo()\n        if event.type == pygame.KEYDOWN and event.mod & pygame.KMOD_CTRL and event.key == pygame.K_y:\n            self.db.redo()\n        elif event.type == pygame.KEYDOWN and event.key == pygame.K_F1:\n            self.debug_bar.toggle()\n        elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE and self.clear_quick_focus():\n            pass\n        else:\n            VBox.process_event(self, event)\n\n    def _on_search_note_open(self, note_id):\n        self.network.open_note(note_id)\n\n    def _on_search_dismiss(self, close):\n        if close:\n            self.search_bar.hide()\n        self.network.focus()\n\n    def _on_search_request(self):\n        self.search_bar.start_search()\n\n    def update(self, rect, elapsed_ms):\n        self.rect = rect\n        VBox.update(self, rect, elapsed_ms)\n\n    def draw(self, canvas):\n        canvas.fill_rect(self.rect, color=COLOR_BACKGROUND)\n        VBox.draw(self, canvas)\n        if self.link_source and not self.link_source.rect.collidepoint(self.pos):\n            canvas.move_to(*self.link_source.rect.center)\n            canvas.line_to(*self.pos)\n            if self.link_target:\n                canvas._set_color(COLOR_ACTIVE)\n            else:\n                canvas._set_color(COLOR_INACTIVE)\n            canvas.set_line_width(5)\n            canvas.stroke()\n",
"type":"code"
}
],
"id":"b8766f8594d4401485c6292c0f2cbeec",
"type":"code"
}
],
"title":"Smart Notes Widget"
},
{
"children":[
{
"children":[],
"id":"fc64ae030cb047b289cfbfd255f8980c",
"paragraphs":[
{
"chunkpath":[
"base classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"137180d5603e43c7a4a6224ea4c709fc",
"type":"variable"
},
{
"text":"(Widget):\n\n    def __init__(self, db, note_id, state):\n        Widget.__init__(self)\n        self.db = db\n        self.note_id = note_id\n        self.state = state\n\n    def is_deleted(self):\n        try:\n            self.db.get_note_data(self.note_id)\n            return False\n        except NoteNotFound:\n            return True\n\n    def is_title(self):\n        return \"title\" in self.data.get(\"tags\", [])\n\n    def update(self, rect, elapsed_ms):\n        self.data = self.db.get_note_data(self.note_id)\n        self.full_width = self.state.get_full_note_width()\n        self.full_height = int(self.full_width*3/5)\n        self.card_full_size = (self.full_width, self.full_height)\n        self.card_full_rect = pygame.Rect((0, 0), self.card_full_size)\n\n    def draw(self, canvas):\n        border_size = 3\n        border = self.rect.copy()\n        border.width -= border_size\n        border.height -= border_size\n        border.x += border_size\n        border.y += border_size\n        canvas.fill_rect(border, color=(0, 0, 0, 50))\n        border.x -= border_size\n        border.y -= border_size\n        canvas.fill_rect(border, color=COLOR_NOTE_BG)\n        canvas.draw_rect(border, (0, 0, 0, 120), 1)\n        if self.has_focus():\n            canvas.draw_rect(border.inflate(-7, -7).move(1, 1), COLOR_SELECTION, 2)\n        canvas.blit(\n            canvas.create_image(\n                self.card_full_size,\n                self._draw_card\n            ),\n            self.rect,\n            scale_to_fit=self.rect.size\n        )\n\n    def _draw_card(self, canvas):\n        border = 8\n        status_height = self.full_width/20\n        rect = self.card_full_rect\n        rect = rect.inflate(-border*4, -border*3-status_height)\n        rect.top = border\n        if DEBUG_NOTE_BORDER:\n            canvas.draw_rect(rect, (200, 50, 50), 1)\n        canvas.render_text(\n            self.data[\"text\"],\n            rect,\n            size=self.full_width/10,\n            textalign=\"center\" if self.is_title() else \"left\",\n            boxalign=\"center\",\n            color=COLOR_NOTE_TEXT,\n            face=FONT_TEXT\n        )\n        rect = rect.inflate(border*2, 0)\n        rect.height = status_height\n        rect.bottom = self.card_full_rect.bottom - border\n        if DEBUG_NOTE_BORDER:\n            canvas.draw_rect(rect, (200, 50, 50), 1)\n        canvas.render_text(\n            self.data[\"timestamp_created\"][:10],\n            rect,\n            size=status_height,\n            face=FONT_MONOSPACE,\n            boxalign=\"bottomleft\",\n            split=False,\n            color=COLOR_NOTE_DATE_TEXT\n        )\n        tags = self.data.get(\"tags\", [])\n        links = self.data.get(\"links\", [])\n        if tags or links:\n            right = rect.right\n            rect.width -= (rect.height*1.3) * len(links)\n            canvas.render_text(\n                \" \".join(\"#{}\".format(tag) for tag in self.data[\"tags\"]),\n                rect,\n                size=status_height,\n                face=FONT_MONOSPACE,\n                boxalign=\"bottomright\",\n                split=False,\n                color=COLOR_NOTE_TAG_TEXT\n            )\n            rect.width = rect.height\n            rect.right = right\n            for link in links:\n                canvas.draw_rect(\n                    rect,\n                    (50, 150, 50),\n                    1\n                )\n                rect = rect.move(-rect.height*1.3, 0)\n\n    def _get_target(self, alotted_rect, align=\"center\"):\n        target = self.card_full_rect\n        target = target.fit(alotted_rect)\n        if align == \"left\":\n            target.midright = alotted_rect.midright\n        elif align == \"right\":\n            target.midleft = alotted_rect.midleft\n        else:\n            target.center = alotted_rect.center\n        return target\n",
"type":"code"
}
],
"id":"5a6d5d5e3655471c96db2681d66bca48",
"type":"code"
}
],
"title":"Note"
}
],
"id":"ce9d57af2dba41ebbc38499a3dde8c7c",
"paragraphs":[],
"title":"Widgets"
},
{
"children":[],
"id":"dc011c5af96c4cf5ba82bb7c79f69563",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"03a7c6b0000146f5ba3d059fd0936900",
"type":"variable"
},
{
"text":"(Immutable):\n\n    def __init__(self, path):\n        Immutable.__init__(self, ",
"type":"code"
},
{
"id":"2237aa8492f74e6da9484546734acc06",
"type":"variable"
},
{
"text":"(path, {\n            \"version\": 1,\n            \"notes\": {},\n            \"links\": {},\n        }))\n        self.path = path\n\n    def ",
"type":"code"
},
{
"id":"a342079796cc418b9f52363ab1ca3cf3",
"type":"variable"
},
{
"text":"(self, expression=\"\"):\n        def match(item):\n            lower_text = item[\"text\"].lower()\n            for part in expression.split(\" \"):\n                if part.startswith(\"#\"):\n                    tagpart = part[1:]\n                    for tag in item.get(\"tags\", []):\n                        if tagpart in tag:\n                            break\n                    else:\n                        return False\n                else:\n                    if part.lower() not in lower_text:\n                        return False\n            return True\n        return sorted(\n            (\n                item\n                for item in self._get(\"notes\").items()\n                if match(item[1])\n            ),\n            key=lambda item: item[1][\"timestamp_created\"],\n            reverse=True\n        )\n\n    def ",
"type":"code"
},
{
"id":"7efd9878f5b944e09e96228ab258303b",
"type":"variable"
},
{
"text":"(self, note_id):\n        self._ensure_note_id(note_id)\n        return self._get(\"notes\", note_id)\n\n    def ",
"type":"code"
},
{
"id":"6b3f131bafd84a0eafcc6a947995a761",
"type":"variable"
},
{
"text":"(self, note_id):\n        return [\n            (link_id, link)\n            for link_id, link in self._get(\"links\").items()\n            if link[\"from\"] == note_id\n        ]\n\n    def ",
"type":"code"
},
{
"id":"4b5405a3ae174b3e9bb6938c905bb18e",
"type":"variable"
},
{
"text":"(self, note_id):\n        return [\n            (link_id, link)\n            for link_id, link in self._get(\"links\").items()\n            if link[\"to\"] == note_id\n        ]\n\n    def ",
"type":"code"
},
{
"id":"0b307bcf1b0c4063a456d2120dfe8ae0",
"type":"variable"
},
{
"text":"(self, **params):\n        note_id = ",
"type":"code"
},
{
"id":"b948d840f9574847ab15f4d31f74b5c6",
"type":"variable"
},
{
"text":"()\n        self._replace(notes=dict(\n            self._get(\"notes\"),\n            **{note_id: dict(params, timestamp_created=",
"type":"code"
},
{
"id":"ce3392bc2bab47e78e5a9d8802772b57",
"type":"variable"
},
{
"text":"())}\n        ))\n        return note_id\n\n    def ",
"type":"code"
},
{
"id":"b31e252cdc2f4776ac95bce3dc27c3f2",
"type":"variable"
},
{
"text":"(self, note_id, **params):\n        self._ensure_note_id(note_id)\n        self._replace(notes=dict(\n            self._get(\"notes\"),\n            **{note_id: dict(self._get(\"notes\", note_id), **params)}\n        ))\n\n    def ",
"type":"code"
},
{
"id":"673acc718f404d9986a6f3898cbbadf2",
"type":"variable"
},
{
"text":"(self, note_id):\n        self._ensure_note_id(note_id)\n        new_notes = dict(self._get(\"notes\"))\n        new_notes.pop(note_id)\n        new_links = dict(self._get(\"links\"))\n        dead_links = []\n        for link_id, link in new_links.items():\n            if link[\"to\"] == note_id or link[\"from\"] == note_id:\n                dead_links.append(link_id)\n        for link_id in dead_links:\n            new_links.pop(link_id)\n        self._replace(notes=new_notes, links=new_links)\n\n    def ",
"type":"code"
},
{
"id":"1d6a87fbf9354dd7a07c9fcf3f92ffb4",
"type":"variable"
},
{
"text":"(self, from_id, to_id):\n        link_id = ",
"type":"code"
},
{
"id":"b948d840f9574847ab15f4d31f74b5c6",
"type":"variable"
},
{
"text":"()\n        self._replace(links=dict(\n            self._get(\"links\"),\n            **{link_id: {\n                \"from\": from_id,\n                \"to\": to_id,\n                \"timestamp_created\": ",
"type":"code"
},
{
"id":"ce3392bc2bab47e78e5a9d8802772b57",
"type":"variable"
},
{
"text":"(),\n            }}\n        ))\n        return link_id\n\n    def ",
"type":"code"
},
{
"id":"9827dd413fa74216bc5c610b7807fb0c",
"type":"variable"
},
{
"text":"(self, link_id):\n        self._ensure_link_id(link_id)\n        new_links = dict(self._get(\"links\"))\n        new_links.pop(link_id)\n        self._replace(links=new_links)\n\n    def _ensure_note_id(self, note_id):\n        if note_id not in self._get(\"notes\"):\n            raise NoteNotFound(str(note_id))\n\n    def _ensure_link_id(self, link_id):\n        if link_id not in self._get(\"links\"):\n            raise LinkNotFound(str(link_id))\n\n    def _replace(self, **kwargs):\n        self._set(dict(self._get(), **kwargs))\n\n    def _data_changed(self):\n        ",
"type":"code"
},
{
"id":"f8996a2073f44381a80ca3f9efd459a4",
"type":"variable"
},
{
"text":"(self.path, self._get())\n",
"type":"code"
}
],
"id":"486ada8dcbd342f496b9909b2660347d",
"type":"code"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class NoteNotFound(ValueError):\n    pass\n",
"type":"code"
}
],
"id":"acea5ef563274bf5836f62a8dbce6a78",
"type":"code"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class LinkNotFound(ValueError):\n    pass\n",
"type":"code"
}
],
"id":"b4807f181734463da0b0a38d68b1c107",
"type":"code"
},
{
"chunkpath":[
"functions"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"def ",
"type":"code"
},
{
"id":"b948d840f9574847ab15f4d31f74b5c6",
"type":"variable"
},
{
"text":"():\n    return uuid.uuid4().hex\n",
"type":"code"
}
],
"id":"61fac0216a5444a799dd67129536b982",
"type":"code"
},
{
"chunkpath":[
"functions"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"def ",
"type":"code"
},
{
"id":"ce3392bc2bab47e78e5a9d8802772b57",
"type":"variable"
},
{
"text":"():\n    return datetime.datetime.utcnow().isoformat()\n",
"type":"code"
}
],
"id":"b68c021bacf0459b87f8a4c2eaf30912",
"type":"code"
}
],
"title":"Data model"
},
{
"children":[],
"id":"36849e57111649e5b280854a96e78956",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"8545e167bfcc4a79a004d99b674f6ca1",
"type":"variable"
},
{
"text":"(",
"type":"code"
},
{
"id":"51e0d946025e49788fa31b8cfbab897a",
"type":"variable"
},
{
"text":"):\n\n    def __init__(self, db, note_id=None):\n        self.db = db\n        self.note_id = note_id\n        ",
"type":"code"
},
{
"id":"51e0d946025e49788fa31b8cfbab897a",
"type":"variable"
},
{
"text":".__init__(self, self._note_to_text(), EDITOR_COMMAND)\n\n    def _note_to_text(self):\n        data = self.db.",
"type":"code"
},
{
"id":"7efd9878f5b944e09e96228ab258303b",
"type":"variable"
},
{
"text":"(self.note_id)\n        links = data.get(\"links\", [])\n        tags = data.get(\"tags\", [])\n        extra = []\n        if links or tags:\n            extra.append(\"\\n\")\n            extra.append(\"--\\n\")\n            for link in links:\n                extra.append(\"link: {}\\n\".format(link))\n            for tag in tags:\n                extra.append(\"tag: {}\\n\".format(tag))\n            extra.append(\"--\\n\")\n        return data[\"text\"] + \"\".join(extra)\n\n    def _new_text(self):\n        self.db.",
"type":"code"
},
{
"id":"b31e252cdc2f4776ac95bce3dc27c3f2",
"type":"variable"
},
{
"text":"(self.note_id, **self._text_to_note_fields())\n\n    def _text_to_note_fields(self):\n        try:\n            return self._parse_footer()\n        except ParseError:\n            return {\n                \"text\": self.text,\n                \"links\": [],\n                \"tags\": [],\n            }\n\n    def _parse_footer(self):\n        data = {\n            \"text\": \"\",\n            \"links\": [],\n            \"tags\": [],\n        }\n        parts = self.text.splitlines(True)\n        if parts and parts.pop(-1).rstrip() == \"--\":\n            while parts and parts[-1].rstrip() != \"--\":\n                part = parts.pop(-1)\n                if part.startswith(\"link: \"):\n                    data[\"links\"].insert(0, part[6:].rstrip())\n                elif part.startswith(\"tag: \"):\n                    data[\"tags\"].insert(0, part[5:].rstrip())\n                else:\n                    raise ParseError(\"unknown field\")\n            if parts:\n                parts.pop(-1)\n                while parts and parts[-1].strip() == \"\":\n                    parts.pop(-1)\n                data[\"text\"] = \"\".join(parts)\n                return data\n        raise ParseError(\"no footer found\")\n",
"type":"code"
}
],
"id":"d8e41e42e3c74c77972240dd961292f6",
"type":"code"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class ParseError(ValueError):\n    pass\n",
"type":"code"
}
],
"id":"7faca746eb97474c9701e11e9f451cf6",
"type":"code"
}
],
"title":"Note External Edit"
}
],
"id":"5b3057938889498f908a3eac28cd7ca7",
"paragraphs":[
{
"chunkpath":[
"imports"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"import datetime\nimport sys\nimport uuid\nimport webbrowser\n",
"type":"code"
}
],
"id":"ad28fa89e1954c108aa37a7f9f6ab91a",
"type":"code"
},
{
"chunkpath":[
"constants"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"DEBUG_NOTE_BORDER = os.environ.get(\"DEBUG_NOTE_BORDER\") == \"yes\"\nDEBUG_TEXT_BORDER = os.environ.get(\"DEBUG_TEXT_BORDER\") == \"yes\"\nDEBUG_ANIMATIONS = os.environ.get(\"DEBUG_ANIMATIONS\") == \"yes\"\nDEBUG = DEBUG_NOTE_BORDER or DEBUG_TEXT_BORDER or DEBUG_ANIMATIONS\n\nUSER_EVENT_CHECK_EXTERNAL      = pygame.USEREVENT\nUSER_EVENT_EXTERNAL_TEXT_ENTRY = pygame.USEREVENT + 1\n",
"type":"code"
}
],
"id":"f3ff9989703b488da14653914fdefcc3",
"type":"code"
},
{
"chunkpath":[
"functions"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"def main():\n    if len(sys.argv) < 2:\n        sys.exit(\"Usage: smartnotes.py <file>\")\n    ",
"type":"code"
},
{
"id":"a0616ad912904531a3479fccd5cb67cd",
"type":"variable"
},
{
"text":"(\n        ",
"type":"code"
},
{
"id":"28992293e2f14729bfa7acc3ba2d153d",
"type":"variable"
},
{
"text":",\n        sys.argv[1]\n    )\n",
"type":"code"
}
],
"id":"22321ef3348041b5a10a3b2509f5d917",
"type":"code"
}
],
"title":"Application"
},
{
"children":[
{
"children":[],
"id":"3adf7f96c87244d7abbafa2a9509fb17",
"paragraphs":[
{
"chunkpath":[
"base base classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class Widget(object):\n\n    _focused_widget = None\n    _stable_focused_widget = None\n    _stored_focus = None\n\n    def __init__(self, width=-1, height=-1, visible=True):\n        self._width = width\n        self._height = height\n        self._visible = visible\n\n    def update(self, rect, elapsed_ms):\n        pass\n\n    def draw(self, canvas):\n        pass\n\n    def store_focus(self):\n        if Widget._stored_focus is None:\n            Widget._stored_focus = (\n                Widget._focused_widget,\n                Widget._stable_focused_widget\n            )\n            Widget._focused_widget = None\n            Widget._stable_focused_widget = None\n\n    def restore_focus(self):\n        if Widget._stored_focus is not None:\n            (\n                Widget._focused_widget,\n                Widget._stable_focused_widget\n            ) = Widget._stored_focus\n            Widget._stored_focus = None\n\n    def has_focus(self):\n        return Widget._focused_widget is self\n\n    def focus(self):\n        if Widget._stable_focused_widget is None:\n            Widget._focused_widget = self\n        else:\n            Widget._stable_focused_widget = self\n\n    def clear_quick_focus(self):\n        if Widget._focused_widget is not None and Widget._stable_focused_widget is not None:\n            Widget._focused_widget = Widget._stable_focused_widget\n            Widget._stable_focused_widget = None\n            return True\n        return False\n\n    def quick_focus(self):\n        if Widget._stable_focused_widget is None:\n            Widget._stable_focused_widget = Widget._focused_widget\n        Widget._focused_widget = self\n\n    def resize(self, width=None, height=None):\n        if width is not None:\n            self._width = width\n        if height is not None:\n            self._height = height\n\n    def get_width(self):\n        return self._width\n\n    def get_height(self):\n        return self._height\n\n    def is_visible(self):\n        return self._visible\n\n    def toggle_visible(self):\n        self._visible = not self._visible\n\n    def quit(self):\n        self.post_event(pygame.QUIT)\n\n    def post_event(self, event_type, **kwargs):\n        pygame.event.post(pygame.event.Event(event_type, **kwargs))\n\n    def process_event(self, event):\n        pass\n",
"type":"code"
}
],
"id":"6a99430bc43c4484a3b09cc6940e7182",
"type":"code"
}
],
"title":"Widget"
},
{
"children":[],
"id":"7b735f9619c14dc7b04190f311fa868f",
"paragraphs":[
{
"chunkpath":[
"base base classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class Padding(Widget):\n\n    def __init__(self, widget, hpadding=None, vpadding=None, **kwargs):\n        Widget.__init__(self, **kwargs)\n        self.widget = widget\n        self.hpadding = (lambda rect: 0) if hpadding is None else hpadding\n        self.vpadding = (lambda rect: 0) if vpadding is None else vpadding\n\n    def process_event(self, event):\n        self.widget.process_event(event)\n\n    def update(self, rect, elapsed_ms):\n        self.widget.update(\n            rect.inflate(-self.hpadding(rect)*2, -self.vpadding(rect)*2),\n            elapsed_ms\n        )\n\n    def draw(self, canvas):\n        self.widget.draw(canvas)\n",
"type":"code"
}
],
"id":"ac24784994a74b8dbf84a2cff60abfe4",
"type":"code"
}
],
"title":"Padding"
},
{
"children":[],
"id":"eaaf7fa4b90c4a9ab387fa4a908f49df",
"paragraphs":[
{
"chunkpath":[
"base classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class Box(Widget):\n\n    def __init__(self, **kwargs):\n        Widget.__init__(self, **kwargs)\n        self.clear()\n\n    def clear(self):\n        self.children = []\n\n    def add(self, child):\n        self.children.append(child)\n        return child\n\n    def process_event(self, event):\n        for child in self.visible_children():\n            child.process_event(event)\n\n    def update(self, rect, elapsed_ms):\n        sizes = []\n        divide_indices = []\n        for child in self.visible_children():\n            if self.get_widget_size(child) == -1:\n                divide_indices.append(len(sizes))\n                sizes.append(0)\n            else:\n                sizes.append(self.get_widget_size(child))\n        if divide_indices:\n            divide_size = int(round((self.get_rect_size(rect) - sum(sizes)) / len(divide_indices)))\n            for divide_index in divide_indices:\n                sizes[divide_index] = divide_size\n        for child, size in zip(self.visible_children(), sizes):\n            rect = self.set_rect_size(rect, size)\n            child.update(rect, elapsed_ms)\n            rect = self.move_rect(rect, size)\n\n    def draw(self, screen):\n        for child in self.visible_children():\n            child.draw(screen)\n\n    def visible_children(self):\n        for child in self.children:\n            if child.is_visible():\n                yield child\n",
"type":"code"
}
],
"id":"d8af363fc7e34f2f9772f3874f6585c7",
"type":"code"
},
{
"chunkpath":[
"base classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class VBox(Box):\n\n    def get_widget_size(self, widget):\n        return widget.get_height()\n\n    def get_rect_size(self, thing):\n        return thing.height\n\n    def set_rect_size(self, rect, size):\n        rect = rect.copy()\n        rect.height = size\n        return rect\n\n    def move_rect(self, rect, delta):\n        return rect.move(0, delta)\n",
"type":"code"
}
],
"id":"a10267c87a54407db9f02e7960f68a0f",
"type":"code"
},
{
"chunkpath":[
"base classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class HBox(Box):\n\n    def get_widget_size(self, widget):\n        return widget.get_width()\n\n    def get_rect_size(self, thing):\n        return thing.width\n\n    def set_rect_size(self, rect, size):\n        rect = rect.copy()\n        rect.width = size\n        return rect\n\n    def move_rect(self, rect, delta):\n        return rect.move(delta, 0)\n",
"type":"code"
}
],
"id":"dfea85776242420eb2e8a4382d41d711",
"type":"code"
}
],
"title":"Box"
},
{
"children":[],
"id":"a750a20eb1174907a9dc393eb50a4bdc",
"paragraphs":[
{
"chunkpath":[
"base classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class TextField(Widget):\n\n    def __init__(self, text_changed_callback, text_size=10, **kwargs):\n        Widget.__init__(self, **kwargs)\n        self.text_size = text_size\n        self.text = \"\"\n        self.text_changed_callback = text_changed_callback\n\n    def set_text(self, text):\n        self.text = text\n        self.text_changed_callback(text)\n\n    def process_event(self, event):\n        if self.has_focus() and event.type == pygame.KEYDOWN and event.unicode:\n            self.set_text(self.text + event.unicode)\n        elif event.type == pygame.MOUSEBUTTONUP and self.rect.collidepoint(event.pos):\n            self.focus()\n\n    def ",
"type":"code"
},
{
"id":"8cce3dd9f80645e6a8df699f872f1736",
"type":"variable"
},
{
"text":"(self, ",
"type":"code"
},
{
"id":"595003a78e1e4326ac5ef9aa70b79fd9",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"7583be08dcbd4bcca0e6a043d3791710",
"type":"variable"
},
{
"text":"):\n        self.rect = rect\n\n    def ",
"type":"code"
},
{
"id":"acab4c17f89046f4a05b14a8c35ad89a",
"type":"variable"
},
{
"text":"(self, canvas):\n        canvas.fill_rect(\n            self.rect,\n            (250, 250, 250)\n        )\n        canvas.render_text(\n            \"{}\\u2302\".format(self.text),\n            self.rect.inflate(-4, -4),\n            face=FONT_MONOSPACE,\n            size=self.text_size,\n            boxalign=\"midleft\"\n        )\n        if self.has_focus():\n            canvas.draw_rect(self.rect, COLOR_SELECTION, 2)\n",
"type":"code"
}
],
"id":"ecbd5ee7aacd41bdbc69df7698f8466f",
"type":"code"
}
],
"title":"Text Field"
},
{
"children":[],
"id":"11abaf23c6a34a8396a6c09893730e3e",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class Animation(object):\n\n    def __init__(self):\n        self.duration_ms = 1\n        self.progress = 1\n        self.last_consumed = True\n\n    def start(self, duration_ms):\n        if DEBUG_ANIMATIONS:\n            duration_ms = duration_ms * 10\n        self.duration_ms = duration_ms\n        self.progress = 0\n        self.last_consumed = False\n\n    def reverse(self, duration_ms):\n        if self.active():\n            self.progress = self.duration_ms - self.progress\n        else:\n            self.start(duration_ms)\n\n    def advance(self, elapsed_ms):\n        percent = float(self.progress) / float(self.duration_ms)\n        if self.progress == self.duration_ms:\n            self.last_consumed = True\n        else:\n            self.progress = min(self.duration_ms, self.progress+elapsed_ms)\n        return percent\n\n    def active(self):\n        return self.progress < self.duration_ms or not self.last_consumed\n",
"type":"code"
}
],
"id":"182ef89406e74661b19b691b2e00b761",
"type":"code"
}
],
"title":"Animation"
}
],
"id":"0b150af1003a44dab87710c2149af734",
"paragraphs":[],
"title":"Widget Framework"
},
{
"children":[
{
"children":[],
"id":"7cc2cbc359ee45d7b20b75890f97870d",
"paragraphs":[
{
"chunkpath":[
"functions"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"def ",
"type":"code"
},
{
"id":"a0616ad912904531a3479fccd5cb67cd",
"type":"variable"
},
{
"text":"(root_widget_cls, *args, **kwargs):\n    pygame.init()\n    root_widget = root_widget_cls(*args, **kwargs)\n    pygame.display.set_caption(format_title(\"Smart Notes\", root_widget.db.path))\n    screen = pygame.display.set_mode((1280, 720), pygame.RESIZABLE)\n    clock = pygame.time.Clock()\n    external_text_entries = ",
"type":"code"
},
{
"id":"fbbc968c81ea43adac03e7f20e8085dd",
"type":"variable"
},
{
"text":"()\n    pygame.time.set_timer(USER_EVENT_CHECK_EXTERNAL, 1000)\n    pygame_cairo_surface = create_pygame_cairo_surface(screen)\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                return\n            elif event.type == pygame.VIDEORESIZE:\n                pygame_cairo_surface = create_pygame_cairo_surface(screen)\n            elif event.type == USER_EVENT_CHECK_EXTERNAL:\n                external_text_entries.check()\n            elif event.type == USER_EVENT_EXTERNAL_TEXT_ENTRY:\n                external_text_entries.add(event.entry)\n            else:\n                root_widget.process_event(event)\n        root_widget.update(screen.get_rect(), clock.get_time())\n        pygame_cairo_surface.lock()\n        root_widget.draw(CairoCanvas(create_cairo_image(pygame_cairo_surface)))\n        pygame_cairo_surface.unlock()\n        screen.blit(pygame_cairo_surface, (0, 0))\n        pygame.display.flip()\n        clock.tick(60)\n",
"type":"code"
}
],
"id":"a87f2f392f1049a49e35d7e75f275130",
"type":"code"
}
],
"title":"Main"
},
{
"children":[],
"id":"da53ba605f7142bfaa5785608a24db3b",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class CairoCanvas(object):\n\n    def __init__(self, surface):\n        self.surface = surface\n        self.ctx = cairo.Context(self.surface)\n\n    def create_image(self, size, fn):\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, size[0], size[1])\n        fn(CairoCanvas(surface))\n        return surface\n\n    def blit(self, image, pos, alpha=255, scale_to_fit=None):\n        self.ctx.save()\n        self.ctx.translate(pos[0], pos[1])\n        if scale_to_fit:\n            self.ctx.scale(\n                max(0.001, scale_to_fit[0] / image.get_width()),\n                max(0.001, scale_to_fit[1] / image.get_height())\n            )\n        self.ctx.set_source_surface(image, 0, 0)\n        self.ctx.paint_with_alpha(alpha/255)\n        self.ctx.restore()\n\n    def fill_rect(self, rect, color=(0, 0, 0)):\n        self._set_color(color)\n        self.ctx.rectangle(rect.x, rect.y, rect.width, rect.height)\n        self.ctx.fill()\n\n    def draw_rect(self, rect, color, width):\n        if width % 2 == 0:\n            offset = 0\n        else:\n            offset = 0.5\n        self._set_color(color)\n        self.ctx.rectangle(rect.x+offset, rect.y+offset, rect.width, rect.height)\n        self.ctx.set_line_width(width)\n        self.ctx.stroke()\n\n    def _set_color(self, color):\n        if len(color) == 4:\n            self.ctx.set_source_rgba(color[0]/255, color[1]/255, color[2]/255, color[3]/255)\n        else:\n            self.ctx.set_source_rgb(color[0]/255, color[1]/255, color[2]/255)\n\n    def render_text(self, text, box,\n        size=40,\n        boxalign=\"center\",\n        face=None,\n        textalign=\"left\",\n        split=True,\n        color=(0, 0, 0)\n    ):\n        if box.height <= 0:\n            return\n        text = text.strip().replace(\"\\n\", \" \")\n        if not text:\n            return\n        if DEBUG_TEXT_BORDER:\n            self.ctx.set_source_rgb(1, 0.1, 0.1)\n            self.ctx.rectangle(box[0], box[1], box[2], box[3])\n            self.ctx.set_line_width(1)\n            self.ctx.stroke()\n        if face is not None:\n            self.ctx.select_font_face(face)\n        self._set_color(color)\n        metrics, scale_factor = self._find_best_fit(text, box, split, size)\n        self.ctx.save()\n        xoffset = 0\n        yoffset = 0\n        self._translate_box(box, metrics[\"width\"]*scale_factor, metrics[\"height\"]*scale_factor, boxalign)\n        self.ctx.scale(scale_factor, scale_factor)\n        for x, y, width, part in metrics[\"parts\"]:\n            if textalign == \"center\":\n                x_align_offset = (metrics[\"width\"]-width)/2\n            elif textalign == \"right\":\n                x_align_offset = metrics[\"width\"]-width\n            else:\n                x_align_offset = 0\n            self.ctx.move_to(x+x_align_offset, y)\n            self.ctx.show_text(part)\n        if DEBUG_TEXT_BORDER:\n            self.ctx.set_source_rgb(0.1, 1, 0.1)\n            self.ctx.rectangle(0, 0, metrics[\"width\"], metrics[\"height\"])\n            self.ctx.set_line_width(2/scale_factor)\n            self.ctx.stroke()\n        self.ctx.restore()\n\n    def _find_best_fit(self, text, box, split, size):\n        self.ctx.set_font_size(size)\n        if split:\n            metrics = self._find_best_split(text, box)\n        else:\n            metrics = self._get_metrics([text])\n        scale_factor = box.width / metrics[\"width\"]\n        if metrics[\"height\"] * scale_factor > box.height:\n            scale_factor = box.height / metrics[\"height\"]\n        scale_factor = min(scale_factor, 1)\n        size = int(size*scale_factor)\n        if scale_factor < 1:\n            while True:\n                self.ctx.set_font_size(size)\n                metrics = self._get_metrics([x[-1] for x in metrics[\"parts\"]])\n                if size < 2:\n                    break\n                if metrics[\"width\"] <= box.width and metrics[\"height\"] <= box.height:\n                    break\n                size -= 1\n        return metrics, 1\n\n    def _find_best_split(self, text, box):\n        split_times = 1\n        target_ratio = box.width / box.height\n        metrics = self._get_metrics(self._split_text(text, split_times))\n        diff = abs(metrics[\"ratio\"] - target_ratio)\n        while True:\n            split_times += 1\n            new_metrics = self._get_metrics(self._split_text(text, split_times))\n            new_diff = abs(new_metrics[\"ratio\"] - target_ratio)\n            if new_metrics == metrics or new_diff > diff:\n                return metrics\n            else:\n                diff = new_diff\n                metrics = new_metrics\n\n    def _split_text(self, text, times):\n        words = text.split(\" \")\n        words_per_part = max(1, int(round(len(words) / times)))\n        parts = []\n        start = 0\n        while start < len(words):\n            parts.append(\" \".join(words[start:start+words_per_part]))\n            start += words_per_part\n        return parts\n\n    def _get_metrics(self, splits):\n        width = 0\n        height = 0\n        start_y = None\n        parts = []\n        font_ascent, font_descent = self.ctx.font_extents()[0:2]\n        extra = font_descent*0.9\n        for text in splits:\n            extents = self.ctx.text_extents(text)\n            height += font_ascent\n            parts.append((-extents.x_bearing, height, extents.width, text))\n            width = max(width, extents.width)\n            height += font_descent\n            height += extra\n        height -= extra\n        return {\n            \"parts\": parts,\n            \"width\": width,\n            \"height\": height,\n            \"ratio\": width / height,\n        }\n\n    def _translate_box(self, box, text_width, text_height, boxalign):\n        # topleft      topcenter     topright\n        # midleft        center      midright\n        # bottomleft  bottomcenter  bottomright\n        if boxalign in [\"topright\", \"midright\", \"bottomright\"]:\n            xoffset = box[2]-text_width\n        elif boxalign in [\"topcenter\", \"center\", \"bottomcenter\"]:\n            xoffset = box[2]/2-text_width/2\n        else:\n            xoffset = 0\n        if boxalign in [\"bottomleft\", \"bottomcenter\", \"bottomright\"]:\n            yoffset = box[3]-text_height\n        elif boxalign in [\"midleft\", \"center\", \"midright\"]:\n            yoffset = box[3]/2-text_height/2\n        else:\n            yoffset = 0\n        self.ctx.translate(box[0]+xoffset, box[1]+yoffset)\n\n    def move_to(self, x, y):\n        self.ctx.move_to(x, y)\n\n    def line_to(self, x, y):\n        self.ctx.line_to(x, y)\n\n    def curve_to(self, *args):\n        self.ctx.curve_to(*args)\n\n    def set_source_rgb(self, *args):\n        self.ctx.set_source_rgb(*args)\n\n    def set_line_width(self, *args):\n        self.ctx.set_line_width(*args)\n\n    def stroke(self, *args):\n        self.ctx.stroke(*args)\n\n    def get_rect(self):\n        return pygame.Rect(\n            0,\n            0,\n            self.surface.get_width(),\n            self.surface.get_height()\n        )\n",
"type":"code"
}
],
"id":"b7c5f48ba9764ed3931b9d54775faad1",
"type":"code"
},
{
"chunkpath":[
"functions"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"def create_pygame_cairo_surface(screen):\n    return pygame.Surface(\n        screen.get_size(),\n        depth=32,\n        masks=(\n            0x00FF0000,\n            0x0000FF00,\n            0x000000FF,\n            0x00000000,\n        )\n    )\n",
"type":"code"
}
],
"id":"58743cb43c5b4a849a6cdf96fa0a8464",
"type":"code"
},
{
"chunkpath":[
"functions"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"def create_cairo_image(pygame_cairo_surface):\n    return cairo.ImageSurface.create_for_data(\n        pygame_cairo_surface.get_buffer(),\n        cairo.FORMAT_ARGB32,\n        *pygame_cairo_surface.get_size()\n    )\n",
"type":"code"
}
],
"id":"7abe0a4f69224dc4b1f735a5b1c18e20",
"type":"code"
}
],
"title":"Canvas"
}
],
"id":"8f8a451c7cb947aa9de69c1955ca8467",
"paragraphs":[
{
"chunkpath":[
"imports"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"import cairo\nimport pygame\n",
"type":"code"
}
],
"id":"5771674cc6c541c0932a9326d5296f95",
"type":"code"
}
],
"title":"Pygame/Cairo"
},
{
"children":[
{
"children":[],
"id":"bad01d8dd67d4561bc1808229e4e7bdc",
"paragraphs":[
{
"chunkpath":[
"base classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class Immutable(object):\n\n    def __init__(self, data, undo_list_size=20):\n        self.data = data\n        self.undo_list_size = undo_list_size\n        self.undo_list = []\n        self.redo_list = []\n        self.transaction_count = 0\n\n    @contextlib.contextmanager\n    def transaction(self):\n        current_data = self.data\n        self.transaction_count += 1\n        try:\n            yield\n        except:\n            self.data = current_data\n            raise\n        finally:\n            self.transaction_count -= 1\n            if self.transaction_count == 0 and self.data is not current_data:\n                self.undo_list.append(current_data)\n                self.undo_list = self.undo_list[-self.undo_list_size:]\n                self.redo_list.clear()\n                self._data_changed()\n\n    def undo(self):\n        if self.transaction_count == 0 and self.undo_list:\n            self.redo_list.insert(0, self.data)\n            self.data = self.undo_list.pop(-1)\n            self._data_changed()\n\n    def redo(self):\n        if self.transaction_count == 0 and self.redo_list:\n            self.undo_list.append(self.data)\n            self.data = self.redo_list.pop(0)\n            self._data_changed()\n\n    def _get(self, *path):\n        data = self.data\n        for part in path:\n            data = data[part]\n        return data\n\n    def _set(self, data):\n        with self.transaction():\n            self.data = data\n\n    def _data_changed(self):\n        pass\n",
"type":"code"
}
],
"id":"8d0dee3395be455bad18f6322eac6657",
"type":"code"
}
],
"title":"Immutable"
},
{
"children":[],
"id":"d2382bb409e441e781fb02e120e6e629",
"paragraphs":[
{
"chunkpath":[
"classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"fbbc968c81ea43adac03e7f20e8085dd",
"type":"variable"
},
{
"text":"(object):\n\n    def __init__(self):\n        self.entries = []\n\n    def add(self, entry):\n        self.entries.append(entry)\n\n    def check(self):\n        self.entries = [\n            entry\n            for entry in self.entries\n            if entry.check()\n        ]\n",
"type":"code"
}
],
"id":"4fdb5de88ff545a79cb7fc955b5380fe",
"type":"code"
},
{
"chunkpath":[
"base classes"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"51e0d946025e49788fa31b8cfbab897a",
"type":"variable"
},
{
"text":"(object):\n\n    def __init__(self, text, editor_command):\n        self.text = text\n        self.f = tempfile.NamedTemporaryFile(suffix=\"-smartnotes-external-\")\n        self.f.write(self.text.encode(\"utf-8\"))\n        self.f.flush()\n        self.p = subprocess.Popen([\n            self.f.name if part is None else part\n            for part\n            in editor_command\n        ])\n\n    def check(self):\n        self.f.seek(0)\n        text = self.f.read().decode(\"utf-8\")\n        if text != self.text:\n            self.text = text\n            self._new_text()\n        if self.p.poll() is not None:\n            self.f.close()\n            return False\n        return True\n\n    def _new_text(self):\n        pass\n",
"type":"code"
}
],
"id":"b16e01bbb1ec4e95b6a30c1ad7b12941",
"type":"code"
}
],
"title":"External Text Entry"
},
{
"children":[],
"id":"51ad7604c03a49618e65fdbe13362e72",
"paragraphs":[
{
"chunkpath":[
"functions"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"def ",
"type":"code"
},
{
"id":"2237aa8492f74e6da9484546734acc06",
"type":"variable"
},
{
"text":"(path, default_value):\n    if os.path.exists(path):\n        with open(path) as f:\n            return json.load(f)\n    else:\n        return default_value\n",
"type":"code"
}
],
"id":"5ef9c213431e485499ca5da086d19013",
"type":"code"
},
{
"chunkpath":[
"functions"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"def ",
"type":"code"
},
{
"id":"f8996a2073f44381a80ca3f9efd459a4",
"type":"variable"
},
{
"text":"(path, value):\n    with ",
"type":"code"
},
{
"id":"12a5523894264ebaaff391fa452cb51c",
"type":"variable"
},
{
"text":"(path) as f:\n        json.dump(value, f)\n",
"type":"code"
}
],
"id":"bed891eb4b214ccf88663a0ca600d368",
"type":"code"
},
{
"chunkpath":[
"functions"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"@contextlib.contextmanager\ndef ",
"type":"code"
},
{
"id":"12a5523894264ebaaff391fa452cb51c",
"type":"variable"
},
{
"text":"(path):\n    tmp_path = f\"{path}.tmp\"\n    with open(tmp_path, \"w\") as f:\n        yield f\n    os.rename(tmp_path, path)\n",
"type":"code"
}
],
"id":"69dbf4c50e7c444b94bdc693909613d4",
"type":"code"
}
],
"title":"JSON"
},
{
"children":[],
"id":"0e0bf8251257430aae941d189de72c0d",
"paragraphs":[
{
"chunkpath":[
"functions"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"def format_title(name, path):\n    return \"{} ({}) - {}\".format(\n        os.path.basename(path),\n        os.path.abspath(os.path.dirname(path)),\n        name\n    )\n",
"type":"code"
}
],
"id":"3698c8b80a724465bce19a8cda8382f8",
"type":"code"
}
],
"title":"Format Title"
},
{
"children":[],
"id":"ab484b553cad4ebea9802ed869b59550",
"paragraphs":[
{
"chunkpath":[
"functions"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"def strip_last_word(text):\n    remaining_parts = text.rstrip().split(\" \")[:-1]\n    if remaining_parts:\n        return \" \".join(remaining_parts) + \" \"\n    else:\n        return \"\"\n",
"type":"code"
}
],
"id":"6e6598d06118446594115047ecf5af5e",
"type":"code"
}
],
"title":"Text Manipulation"
}
],
"id":"ec7b63d28b90469cbbbbb9221dec1ecf",
"paragraphs":[
{
"chunkpath":[
"imports"
],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"import contextlib\nimport json\nimport os\nimport subprocess\nimport tempfile\n",
"type":"code"
}
],
"id":"c13b5d10090043e898ea5d7e381fd3c5",
"type":"code"
}
],
"title":"Utilities"
}
],
"id":"4b9f83dd3a9c454e917cf4c9431ea3ae",
"paragraphs":[
{
"fragments":[
{
"text":"Smart Notes is implemented in layers. The application itself is written using a widget framework. The widget framework is designed to meet only the needs of the application, although it might be usable as a base for other projects as well. The widget framework is realized using pygame and Cairo. Neither the application nor the widget framework knows about pygame or Cairo. All layers might use utility functions. Utilities are considered fairly generic.",
"type":"text"
}
],
"id":"a59277814b3243af9108dac2b888f989",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"+------------------------+\n|  Application           |\n+--------------------+-+-+\n|  Widget Framework  | |\n+----------------+-+-+ |\n                   |   |\n+----------------+ |   |\n|  Pygame/Cairo  | |   |\n+----------------+ |   |\n         v         v   v\n+------------------------+\n|      Utilities         |\n+------------------------+\n",
"type":"code"
}
],
"id":"d2d2fe22f9754c6e88fc576f3406abaf",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"smartnotes.py"
],
"fragments":[
{
"text":"#!/usr/bin/env python3\n\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"imports"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\n",
"type":"code"
},
{
"blank_lines_before":1,
"path":[
"constants"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\n",
"type":"code"
},
{
"blank_lines_before":1,
"path":[
"base base classes"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\n",
"type":"code"
},
{
"blank_lines_before":1,
"path":[
"base classes"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\n",
"type":"code"
},
{
"blank_lines_before":1,
"path":[
"classes"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\n",
"type":"code"
},
{
"blank_lines_before":1,
"path":[
"functions"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\nif __name__ == \"__main__\":\n    main()\n",
"type":"code"
}
],
"id":"49b4e383e1854887a05f4d5b604f2ed4",
"type":"code"
}
],
"title":"Smart Notes"
},
"variables":{
"03a7c6b0000146f5ba3d059fd0936900":"NoteDb",
"0b307bcf1b0c4063a456d2120dfe8ae0":"create_note",
"12a5523894264ebaaff391fa452cb51c":"safe_write",
"137180d5603e43c7a4a6224ea4c709fc":"NoteBaseWidget",
"1d6a87fbf9354dd7a07c9fcf3f92ffb4":"create_link",
"2237aa8492f74e6da9484546734acc06":"read_json_file",
"28992293e2f14729bfa7acc3ba2d153d":"SmartNotesWidget",
"4b5405a3ae174b3e9bb6938c905bb18e":"get_incoming_links",
"51e0d946025e49788fa31b8cfbab897a":"ExternalTextEntry",
"550c4c8b55b444af9a0463ba8be1c5b9":"open_note",
"595003a78e1e4326ac5ef9aa70b79fd9":"rect",
"673acc718f404d9986a6f3898cbbadf2":"delete_note",
"6b3f131bafd84a0eafcc6a947995a761":"get_outgoing_links",
"7583be08dcbd4bcca0e6a043d3791710":"elapsed_ms",
"7efd9878f5b944e09e96228ab258303b":"get_note_data",
"8545e167bfcc4a79a004d99b674f6ca1":"NoteText",
"8cce3dd9f80645e6a8df699f872f1736":"update",
"937919ed2e2c41cca33d85a681729a69":"NetworkWidget",
"9827dd413fa74216bc5c610b7807fb0c":"delete_link",
"a0616ad912904531a3479fccd5cb67cd":"pygame_main",
"a342079796cc418b9f52363ab1ca3cf3":"get_notes",
"ac730e733b7b46e49245a174f805ac8d":"NetworkNote",
"acab4c17f89046f4a05b14a8c35ad89a":"draw",
"b31e252cdc2f4776ac95bce3dc27c3f2":"update_note",
"b948d840f9574847ab15f4d31f74b5c6":"genid",
"c2242de47b1049bb9dddb0f72abeea0c":"LinkWidget",
"cd2f36e35f064625b59853c0192fd724":"rect",
"ce3392bc2bab47e78e5a9d8802772b57":"utcnow_timestamp_string",
"f8996a2073f44381a80ca3f9efd459a4":"write_json_file",
"fbbc968c81ea43adac03e7f20e8085dd":"ExternalTextEntries"
}
}